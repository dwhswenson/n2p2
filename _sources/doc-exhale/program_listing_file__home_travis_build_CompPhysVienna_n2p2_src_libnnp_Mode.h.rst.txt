
.. _program_listing_file__home_travis_build_CompPhysVienna_n2p2_src_libnnp_Mode.h:

Program Listing for File Mode.h
===============================

|exhale_lsh| :ref:`Return to documentation for file <file__home_travis_build_CompPhysVienna_n2p2_src_libnnp_Mode.h>` (``/home/travis/build/CompPhysVienna/n2p2/src/libnnp/Mode.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   // n2p2 - A neural network potential package
   // Copyright (C) 2018 Andreas Singraber (University of Vienna)
   //
   // This program is free software: you can redistribute it and/or modify
   // it under the terms of the GNU General Public License as published by
   // the Free Software Foundation, either version 3 of the License, or
   // (at your option) any later version.
   //
   // This program is distributed in the hope that it will be useful,
   // but WITHOUT ANY WARRANTY; without even the implied warranty of
   // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   // GNU General Public License for more details.
   //
   // You should have received a copy of the GNU General Public License
   // along with this program.  If not, see <https://www.gnu.org/licenses/>.
   
   #ifndef MODE_H
   #define MODE_H
   
   #include "CutoffFunction.h"
   #include "Element.h"
   #include "ElementMap.h"
   #include "Log.h"
   #include "Settings.h"
   #include "Structure.h"
   #include "SymmetryFunction.h"
   #include <cstddef> // std::size_t
   #include <string>  // std::string
   #include <vector>  // std::vector
   
   namespace nnp
   {
   
   class Mode
   {
   public:
       Mode();
       void                     initialize();
       void                     loadSettingsFile(std::string const& fileName
                                                                    = "input.nn");
       void                     setupGeneric();
       void                     setupNormalization();
       void                     setupElementMap();
       void                     setupElements();
       void                     setupCutoff();
       void                     setupSymmetryFunctions();
       void                     setupSymmetryFunctionScalingNone();
       void                     setupSymmetryFunctionScaling(
                                    std::string const& fileName = "scaling.data");
       void                     setupSymmetryFunctionGroups();
       void                     setupSymmetryFunctionStatistics(
                                                bool collectStatistics,
                                                bool collectExtrapolationWarnings,
                                                bool writeExtrapolationWarnings,
                                                bool stopOnExtrapolationWarnings);
       void                     setupNeuralNetwork();
       void                     setupNeuralNetworkWeights(
                                    std::string const& fileNameFormat
                                                          = "weights.%03zu.data");
       void                     calculateSymmetryFunctions(
                                                          Structure& structure,
                                                          bool const derivatives);
       void                     calculateSymmetryFunctionGroups(
                                                          Structure& structure,
                                                          bool const derivatives);
       void                     calculateAtomicNeuralNetworks(
                                                    Structure& structure,
                                                    bool const derivatives) const;
       void                     calculateEnergy(Structure& structure) const;
       void                     calculateForces(Structure& structure) const;
       /* Add atomic energy offsets to reference energy.
        *
        * @param[in] structure Input structure.
        * @param[in] ref If true, use reference energy, otherwise use NN energy.
        */
       void                     addEnergyOffset(Structure& structure,
                                                bool       ref = true);
       /* Remove atomic energy offsets from reference energy.
        *
        * @param[in] structure Input structure.
        * @param[in] ref If true, use reference energy, otherwise use NN energy.
        *
        * This function should be called immediately after structures are read in.
        */
       void                     removeEnergyOffset(Structure& structure,
                                                   bool       ref = true);
       /* Get atomic energy offset for given structure.
        *
        * @param[in] structure Input structure.
        *
        * @return Summed atomic energy offsets for structure.
        */
       double                   getEnergyOffset(Structure const& structure) const;
       /* Add atomic energy offsets and return energy.
        *
        * @param[in] structure Input structure.
        * @param[in] ref If true, use reference energy, otherwise use NN energy.
        *
        * @return Reference or NNP energy with energy offsets added.
        *
        * @note If normalization is used, ensure that structure energy is already
        * in physical units.
        */
       double                   getEnergyWithOffset(
                                               Structure const& structure,
                                               bool             ref = true) const;
       double                   normalizedEnergy(double energy) const;
       double                   normalizedEnergy(
                                               Structure const& structure,
                                               bool             ref = true) const;
       double                   normalizedForce(double force) const;
       double                   physicalEnergy(double energy) const;
       double                   physicalEnergy(Structure const& structure,
                                               bool             ref = true) const;
       double                   physicalForce(double force) const;
       void                     convertToNormalizedUnits(
                                                      Structure& structure) const;
       void                     convertToPhysicalUnits(
                                                      Structure& structure) const;
       std::size_t              getNumExtrapolationWarnings() const;
       void                     resetExtrapolationWarnings();
       double                   getMeanEnergy() const;
       double                   getConvEnergy() const;
       double                   getConvLength() const;
       double                   getMaxCutoffRadius() const;
       std::size_t              getNumElements() const;
       std::vector<std::size_t> getNumSymmetryFunctions() const;
       bool                     useNormalization() const;
       bool                     settingsKeywordExists(
                                                std::string const& keyword) const;
       std::string              settingsGetValue(
                                                std::string const& keyword) const;
       std::vector<std::size_t> pruneSymmetryFunctionsRange(double threshold);
       std::vector<std::size_t> pruneSymmetryFunctionsSensitivity(
                                               double threshold,
                                               std::vector<
                                               std::vector<double> > sensitivity);
       void                     writePrunedSettingsFile(
                                                 std::vector<std::size_t> prune,
                                                 std::string              fileName
                                                             = "output.nn") const;
       void                     writeSettingsFile(
                                                std::ofstream* const& file) const;
   
       ElementMap elementMap;
       Log        log;
   
   protected:
       bool                          normalize;
       bool                          checkExtrapolationWarnings;
       std::size_t                   numElements;
       std::vector<std::size_t>      minNeighbors;
       std::vector<double>           minCutoffRadius;
       double                        maxCutoffRadius;
       double                        cutoffAlpha;
       double                        meanEnergy;
       double                        convEnergy;
       double                        convLength;
       Settings                      settings;
       SymmetryFunction::ScalingType scalingType;
       CutoffFunction::CutoffType    cutoffType;
       std::vector<Element>          elements;
   };
   
   // Inlined function definitions //
   
   inline double Mode::getMeanEnergy() const
   {
       return meanEnergy;
   }
   
   inline double Mode::getConvEnergy() const
   {
       return convEnergy;
   }
   
   inline double Mode::getConvLength() const
   {
       return convLength;
   }
   
   inline double Mode::getMaxCutoffRadius() const
   {
       return maxCutoffRadius;
   }
   
   inline std::size_t Mode::getNumElements() const
   {
       return numElements;
   }
   
   inline bool Mode::useNormalization() const
   {
       return normalize;
   }
   
   }
   
   #endif
